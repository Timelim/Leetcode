### 8/12
|题号||  
| :-----| ----: |
|~~88~~|
|~~700~~|
|~~869~~|
|~~1299~~|
|~~336~~|暴力+剪枝(可改用字典树)|
|910|最小差值|

### 树
|题号|||
| :-----| ----: | ----: |
|94|中序遍历|
|95|二叉搜索树构造|递归方法|
|98|验证二叉搜索树|递归方法|
|100|相同的树||
|101|对称二叉树|递归与非递归|
|102|层序遍历||
|103|锯齿形层序遍历||
|104|二叉树高度||
|105|前序中序构造二叉树||
|106|后序中序构造二叉树||
|107|层次遍历Ⅱ|C++|
|108|构建二叉搜索树|C++|
|110|平衡二叉树||
|111|二叉树最小深度||
|112|路径的和||
|113|路径的和Ⅱ|简单回溯加递归|
|114|二叉树转换为链表||
|116|填充每个节点的下一个右侧节点指针||
|117|填充每个节点的下一个右侧节点指针2||
-------------------
### 树的note

    100 相同的树
    [1,1],和[1,null,1]前序，中序都相同
    解决方法：在前序中序的遍历中加入null
    备注：真是一个sb的题目
    可用101的方法解决
    
    101 对称二叉树
    非递归方法应该从递归方法思考，通过递归的方法改写成迭代
    
    102 层序遍历
    注意 每一层执行完后队列的长度，就是下一层的节点数目
    
    104 二叉树高度
    java的max方法。Math.max(int a,int b)
    不然会导致时间溢出
    
    105和106
    注意递归的时候构造树的索引问题，困着做题果然不行
    
    113
    经典题型，递归里面加一个简单回溯。好长时间不写忘记了写法。
    同时注意 List<List<Integer>> add操作，要调用ArrayList的构造函数! 
    res.add(new ArrayList<>(pathRes));
    
    116
    常数级的解题空间，不能用层次遍历
    
    117
    恢复性刷题 先遍历右子树
    
 ### 栈
 |题号|||
 | :-----| ----: | ----: |
 |94|中序遍历|
 
### problem
    整数反转：一种判断整数是否溢出的简单方法，用整数做之前的逆运算，验证和之前的数是否一致
    
   